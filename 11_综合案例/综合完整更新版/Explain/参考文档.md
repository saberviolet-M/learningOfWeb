[TOC]

## 后台数据管理系统

接口文档: https://www.showdoc.com.cn/escook?page_id=3707158761215217（接口基地址更换'http://api-breakingnews-web.itheima.net'）

axios文档: http://www.axios-js.com/

layui文档: https://www.layui.com/doc/

cropperjs(图片裁剪插件):

* github文档:  https://github.com/fengyuanchen/cropperjs/blob/master/README.md

* example: https://fengyuanchen.github.io/cropperjs/

tinymce(富文本插件): http://tinymce.ax-z.cn/

## 项目介绍

* 注册页面

![image-20201130225406319](images/image-20201130225406319.png)

* 登录页面

![image-20201130225329891](images/image-20201130225329891.png)

* 登录后 - 首页

![image-20201130224404769](images/image-20201130224404769.png)

* 类别管理

![image-20201130225526338](images/image-20201130225526338.png)

* 编辑类别

![image-20201130225556930](images/image-20201130225556930.png)

* 文章列表

![image-20201130230241772](images/image-20201130230241772.png)

* 发布文章

![image-20201130230308211](images/image-20201130230308211.png)

* 基本资料

![image-20201130230332028](images/image-20201130230332028.png)

* 重置密码

![image-20201130230350254](images/image-20201130230350254.png)

* 更换头像

![image-20201130230408765](images/image-20201130230408765.png)



`小结`

1. 用户  和  文章
2. jq + axios + layui + 某插件
   1. jq=>简化DOM操作  兼容性好
   2. **axios** => 发送ajax请求  语法有点奇怪  =>  简洁
   3. **layui** => 相当于Boostrap =>  标签和样式 =>  找文档 复制  简单修改



## 项目目录准备

必须确保vscode 有live Server插件 (内置一个浏览页面的本地服务器 http://127.0.0.1:5050 来预览你的网页

* fonts - 项目用到的字体图标

* images - 项目涉及到的前端静态图片

* lib - 工具包
  * cropper - 图片裁剪插件 (基于jQuery.js)

  * layui - layui.css 和layui.js  官网:https://www.layui.com/

    类似于bootstrap的作用 -

  * tinymce - 富文本编辑器(带样式的输入域)插件

![image-20201215134430324](images/image-20201215134430324.png)

* 在同级下, 再准备登陆页, 和项目的根页面(首页)

![image-20201201224644132](images/image-20201201224644132.png)

`小结`

1. 新建空目录  导入小素材 assets文件夹
2. VSCode安装liveServer插件(模拟真实的开发环境) => 自动刷新
   1. 找到要执行的html
   2. 右键选择  xxx  liveServer  打开
3. 新建了2个html文件 
   1. login.html
   2. index.html

## 1. login页面

### 1.0 标签和样式

* 先引入layui.css 和 login.css(自己的)

```html
<!-- logo -->
<div id="logo">
    <img src="./assets/images/logo.png" />
</div>

<!-- 登录的盒子 -->
<div id="login">
    <!-- 盒子的标题 -->
    <div class="title"></div>
    <!-- 登录的表单 -->
    <form  class="layui-form">
        <!-- 第一行：用户名 -->
        <div class="layui-form-item">
            <i class="layui-icon layui-icon-username"></i>
            <!-- lay-verify表单验证: 更多参考: https://www.layui.com/doc/modules/form.html -->
            <input type="text" name="username" required lay-verify="required" placeholder="请输入用户名"
                   autocomplete="off" class="layui-input">
        </div>
        <!-- 第二行：密码 -->
        <div class="layui-form-item">
            <i class="layui-icon layui-icon-password"></i>
            <input type="password" name="password" required lay-verify="required" placeholder="请输入密码"
                   autocomplete="off" class="layui-input">
        </div>
        <!-- 第三行：按钮 -->
        <div class="layui-form-item">
            <button class="layui-btn layui-btn-fluid layui-bg-blue" lay-submit>登录</button>
        </div>
        <!-- 第四行：去注册账号 -->
        <div class="layui-form-item">
            <a href="javascript:;" id="goto-register">去注册账号</a>
        </div>
    </form>
</div>

<!-- 注册的盒子 -->
<div id="register">
    <!-- 盒子的标题 -->
    <div class="title"></div>

    <!-- 注册的表单 -->
    <form class="layui-form">
        <!-- 第一行：用户名 -->
        <div class="layui-form-item">
            <i class="layui-icon layui-icon-username"></i>
            <input type="text" name="username" required lay-verify="required" placeholder="请输入用户名"
                   autocomplete="off" class="layui-input">
        </div>

        <!-- 第二行：密码 -->
        <div class="layui-form-item">
            <i class="layui-icon layui-icon-password"></i>
            <input type="password" name="password" required lay-verify="required" placeholder="请输入密码"
                   autocomplete="off" class="layui-input pwd">
        </div>

        <!-- 第三行：重复密码 -->
        <div class="layui-form-item">
            <i class="layui-icon layui-icon-password"></i>
            <input type="password" required lay-verify="required" placeholder="请再次输入密码"
                   autocomplete="off" class="layui-input">
        </div>

        <!-- 第四行：按钮 -->
        <div class="layui-form-item">
            <button class="layui-btn layui-btn-fluid layui-bg-blue" lay-submit>注册</button>
        </div>
        <!-- 第五行：有账号，去登录 -->
        <div class="layui-form-item">
            <a href="javascript:;" id="goto-login">已有账号，去登录</a>
        </div>
    </form>
</div>
```

* 再引入login.css里代码

```css
html,
body {
  height: 100%;
  background: url('../assets/images/login_bg.jpg') no-repeat;
  background-size: cover;
  overflow: hidden;
  /* 去掉滚动条 */
}


/* logo */
#logo {
  margin: 20px 0 0 130px;
}


/* 登录和注册的盒子 */
#login,
#register {
  height: 310px;
  width: 400px;
  background-color: #fff;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}


/* 先让注册的盒子隐藏 */
#register {
  display: none;
}

.title {
  /* ../   ./  相对当前文件找路径*/
  /* /   绝对路径，找根路径 */
  height: 60px;
  background: url('../assets/images/login_title.png') no-repeat center;
}


/* 表单 */
.layui-form {
  margin: 0 30px;
}

#goto-register,
#goto-login {
  float: right;
}


/* 字体图标 */
.layui-form-item {
  position: relative;
}

.layui-icon {
  position: absolute;
  top: 10px;
  left: 5px;
}

.layui-input {
  padding-left: 25px;
}
```

### 1.1 切换注册和登录

在login.js中, 使用jQ代码实现切换2套div效果

```js
/**
* 1. 注册/登录 表单 切换
*/
$("#goto-register").on("click", () => {
    $("#register").stop().show();
})
$("#goto-login").on("click", () => {
    $("#register").stop().hide();
})
```

> ### 补充讲解 - layui

* 表单输入框 - 是如何复制的
* 表单输入框 - 前面小图标是如何添加的(使用layui.css默认的类名)
* 表单输入框 - 表单验证 (lay-verify属性 - 必须要引入layui.js才生效, 而且form标签内的按钮需要lay-submit属性才有默认提示效果)

### 1.2 注册 - 验证输入框

1. 结构层中 form>item>input位置 lay-verify="required|规则2|规则2"
2. 规则可以自定义  js代码中  form.verify({ 语法有两种, 函数和数组})=>规则名字 比如username=>和email用法一样

这里借助layui插件里的表单验证

* 先引入layui.js

```js
var form = layui.form; // 引用layui.js后, 有layui对象(类似于$), 然后拿到内部的form对象(用来管理所有用layui创建的表单-以及使用了lay-veify属性的标签)

form.verify({ // 指定规则名和对应的验证规则
    usern: [ // 用户名
        /^[a-z0-9]{6,10}$/,
        '账号名是6到10位由数字, 小写字母组成'
    ],
    pwd: [ // 密码
        /^[\S]{6,10}$/,
        '密码是6到10位, 不能有空格'
    ],
    // 注册页-确认密码
    repwd: function (value) { // 为什么用函数, 因为不光要获取这个规则对应的标签的值, 还需要用jQ获取另外一个标签的值
        return ($(".pwd").val() !== value) && '两次密码不相同'
    },
})
```

* 在注册页 - 违反以上规则 - 观察是否有提示出现

![image-20201215122101980](images/image-20201215122101980.png)

### 1.3 注册 - 提交

整个项目都不适用form标签自带的提交效果和功能, 我们要阻拦form的submit事件, 自己用Ajax来提交form标签里所有表单的name属性和value属性的值

`注意`     后台要key=value&key=value字符串

```js
$("#register .layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = {
        username: $("#register input[name=username]").val(),
        password: md5($("#register input[name=password]").val())
    }
    
    // 后台要key=value&key=value字符串
    var arr = [];
    for (var k in data) {
        arr.push(`${k}=${data[k]}`);
    }
    var argStr = arr.join("&");
    
    axios({
        method: "POST",
        data: argStr,
        url: "http://123.57.109.30:3007/api/reguser"
    }).then(res => {
        console.log(res);
        // 显示登录页面 - 让用户登录
        $("#register").stop().hide();
    });
})
```

`小结`

1. debugger
2. 看到容器(arr和obj), 遍历
3. 数组和对象  保存数据
4. forin=>   push => join

### 1.4 登录 - 验证输入框+提交

* 我们可以使用之前定义好的规则,直接用到对应标签的lay-verify属性的值上即可实现验证规则

```js
$("#login .layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = {
        username: $("#login input[name=username]").val(),
        password: md5($("#login input[name=password]").val())
    }
    
    // 后台要key=value&key=value字符串
    var arr = [];
    for (var k in data) {
        arr.push(`${k}=${data[k]}`);
    }
    var argStr = arr.join("&");
    
    axios({
        method: "POST",
        data: argStr,
        url: "http://123.57.109.30:3007/api/login"
    }).then(res => {
        console.log(res);
        // 登录成功跳转到首页
        window.location.href = "./index.html";
    });
})
```

### 1.5 layer弹窗和status解释

```js
var layer = layui.layer;
let { message, status } = response.data; // 把后台返回的对象, 解构赋值, message后台返回的提示消息, status后台返回的逻辑状态码(0完全成功(逻辑正确, 注册成功), 1网络请求虽然成功了, 但是逻辑失败了(用户名已占用))
layer.msg(message);
```

### ==1.6 common/utils.js自定义工具==

* 引出: 我们发现2段代码里都出现了 把对象转成key=value&key=value的字符串, 以后可能也会用到, 不如封装一个工具方法(秘书) - 我们把对象传给他, 它在工具方法里加工完我们返回key=value&key=value的字符串就可以了

* 大型项目里 - 一般都有一个工具类 (名字随便定义, 一般叫common文件夹 / utils.js的方法仓库文件)

新建common文件夹, 这里放的都是各种自定义的工具(一般只在这个项目下用)

下属新建 - utils.js - 用于定义整个项目 公共的工具方法, 只要引入这个文件, 就都可以使用

```js
// 把JS对象 - 转成key=value&key=value字符串
const objToArg = obj => {
    var arr = [];
    for (var k in obj){
        arr.push(`${k}=${obj[k]}`);
    }
    return arr.join("&");
}
```

* 把utils.js 引入到login.html中, 把上面的注册和登录的 - 代码替换感受一下 封装的好处(优化代码)

```js
$("#login .layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = {
        username: $("#login input[name=username]").val(),
        password: md5($("#login input[name=password]").val())
    }
    var argStr = objToArg(data);
    axios({
        method: "POST",
        data: argStr,
        url: "http://123.57.109.30:3007/api/login"
    }).then(res => {
        console.log(res);
        // 登录成功跳转到首页
        window.location.href = "./index.html";
    });
})
```

### ==1.7 api统一管理接口==

* 引出: 我们上面有2处axios网络请求(内部是Ajax请求) - 以后肯定在不同的功能.js文件里 - 到处散落着网络请求 - 如果以后想要修改url地址 / 请求方式 / 统一管理, 还得挨个文件翻看 (所以不如统一放到一个文件里管理)
* 而且axios方法也重复出现了 / 两段代码很像 / 能否封装一下呢?

在项目根目录下,  新建api文件夹, 

下属新建api.js, 所有的请求都写在这里 - 每个请求一个方法( 逻辑页面的.js 直接使用这个网络请求的方法等着返回数据就可以了)

* api.js里的代码如下

```js
// axios.defaults.baseURL = "http://123.57.109.30:3007";
const registerAPI = function (data, fn) {
    axios({
        method: "POST",
        data: data,
        url: "/api/reguser"
    }).then(function (res) {
        fn(res);
    })
}
// 如果能力强的同学可以简写成箭头函数
// const registerAPI = (data, fn) => axios({
//     method: "POST",
//     data: data,
//     url: "/api/reguser"
// }).then(fn); // fn是外面传进来的函数体, 正好替换then()里的函数体

// 登录的和上面结构一样
const loginAPI = (data, fn) => axios({
    method: "POST",
    data: data,
    url: "/api/login"
}).then(fn);
```

* 替换上面注册和登录的代码网络请求部分

```js
$("#login .layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = {
        username: $("#login input[name=username]").val(),
        password: md5($("#login input[name=password]").val())
    }
    var argStr = objToArg(data);
    loginAPI(argStr, () => { // 这里替换成了api.js封装的方法 - 代码看起来更优雅了
        window.location.href = "./index.html";
    });
})
```

### 1.8 axios响应拦截器

```js
axios.interceptors.response.use(function (response) { // 当http状态为2开头或者3开头进这里
    // 对响应数据做点什么
    var layer = layui.layer;
    let { message, status } = response.data; 
    layer.msg(message); // 逻辑上无论正确还是错误, 都要弹窗
    if (status == 0) { // 逻辑码为0的时候, 执行then里的回调函数
        return response; // 就是把响应的数据传给then的回调函数的形参上
    } else { // 逻辑码为非0, 逻辑错误, 不让then执行了
        return Promise.reject(message); // 必须要return一个Promise的错误到控制台中, 阻止then的回调函数执行
    }
}, function (error) { // 当http状态码为4或5开头, 进这里
   
    // 对响应错误做点什么
    return Promise.reject(error);
});
```

## 2. index页面

管理的首页-页面

`注意`: layui的页面交互效果需要引入layui.all.js文件才能生效!

### 2.0 标签和样式

```html
<body class="layui-layout-body">
    <div class="layui-layout layui-layout-admin">
        <!-- 头部区域 -->
        <div class="layui-header">
            <!-- 左侧：图片 -->
            <div class="layui-logo">
                <img src="./assets/images/logo.png" alt="">
            </div>
            <!-- 右侧：个人菜单 -->
            <ul class="layui-nav layui-layout-right">
                <li class="layui-nav-item">
                    <a href="javascript:;" class="userinfo">
                        <span class="avatar">L</span>
                        <img src="./assets/images/sample.jpg" class="layui-nav-img"> 个人中心
                    </a>

                    <dl class="layui-nav-child">
                        <dd><a href="./iframe/user/userInfo/userInfo.html" target='fm'>基本资料</a></dd>
                        <dd><a target='fm' href="./iframe/user/avatar/avatar.html">更换头像</a></dd>
                        <dd><a target="fm" href="./iframe/user/repwd/repwd.html">重置密码</a></dd>
                    </dl>
                </li>

                <li class="layui-nav-item">
                    <a href="javascript:;" id="logout">
                        <i class="layui-icon layui-icon-logout"></i>退出
                    </a>
                </li>
            </ul>
        </div>

        <div class="layui-side layui-bg-black">
            <div class="layui-side-scroll">
                <!-- 左侧：顶部欢迎词 -->
                <div class="userinfo">
                    <span class="avatar">L</span>
                    <img src="./assets/images/sample.jpg" class="layui-nav-img"> 欢迎你
                    <span class="username"></span>
                </div>

                <!-- 左侧：导航区-->
                <!-- lay-shrink: 控制兄弟菜单, all就是所有兄弟都合上, 同一个时间只有一个下拉菜单才能下拉 -->
                <ul class="left-nav layui-nav layui-nav-tree" lay-filter="test" lay-shrink="all">
                    <!-- **********************首页***************************** -->
                    <!-- layui-this 默认上来高亮的样式 -->
                    <li class="layui-nav-item layui-this">
                        <a href="./iframe/home/home.html" target="fm">
                            <i class="layui-icon layui-icon-home"></i>可视数据
                        </a>
                    </li>

                    <!-- *******文章管理******* -->
                    <li class="layui-nav-item">

                        <a class="" href="javascript:;">
                            <i class="layui-icon layui-icon-form"></i>文章管理
                        </a>

                        <dl class="layui-nav-child">
                            <dd>
                                <a href="./iframe/article/category/category.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>类别管理
                                </a>
                            </dd>


                            <dd id="wzlist">
                                <a href="./iframe/article/list/list.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>文章列表
                                </a>
                            </dd>


                            <dd>
                                <a href="./iframe/article/publisher/publisher.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>发表文章
                                </a>
                            </dd>
                        </dl>
                    </li>

                    <!-- **************个人中心************** -->
                    <li class="layui-nav-item">

                        <a href="javascript:;">
                            <i class="layui-icon layui-icon-user"></i>个人中心
                        </a>

                        <dl class="layui-nav-child">

                            <dd>
                                <a href="./iframe/user/userInfo/userInfo.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>基本资料
                                </a>
                            </dd>

                            <dd>
                                <a href="./iframe/user/repwd/repwd.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>重置密码
                                </a>
                            </dd>

                            <dd>
                                <a href="./iframe/user/avatar/avatar.html" target="fm">
                                    <i class="layui-icon layui-icon-app"></i>更换头像
                                </a>
                            </dd>
                        </dl>
                    </li>

                </ul>
            </div>
        </div>

        <div class="layui-body">
            <!-- 内容主体区域 -->
            <!-- <div style="padding: 15px;">内容主体区域</div> -->
            <iframe src="./iframe/home/home.html" name="fm" frameborder="0"></iframe>
        </div>

        <div class="layui-footer">
            <!-- 底部固定区域 -->
            © layui.com - 底部固定区域
        </div>
    </div>
</body>
```

项目根目录下新建index文件夹

* 下属index.css

```css
.layui-icon {
  margin-right: 8px;
  font-size: 16px;
}

.layui-icon-app {
  margin-left: 20px;
}

iframe {
  width: 100%;
  height: 100%;
}


/* 给iframe的父元素加 overlow: hidden，目的是去掉一个滚动条 */
.layui-body {
  overflow: hidden;
}


/* 侧边栏头像 */
div.userinfo {
  line-height: 60px;
  text-align: center;
}


/* 字体头像 */
.avatar {
  display: inline-block;
  width: 32px;
  height: 32px;
  background-color: #419488;
  line-height: 32px;
  text-align: center;
  border-radius: 50%;
}


/*开始让两个头像都隐藏*/
.userinfo img,
.userinfo .avatar {
  display: none;
}
```

### 2.3 安全 - 防止直接进入首页

如果用户知道首页的index.html地址, 不想登录就直接进入index.html页面 - 这是一件非常危险的事情 (不能让用户看到首页的样子)

```js
// 在index.html对应的index.js 第一行 - 加入判断
// 思路: 登录没登录区别是什么?  是不是在sessionStorage有个值? 如果登录成功会保存token到sessionStorage, 所以只要判断sessionStorage无值, 证明当前用这个浏览器登录网页的家伙 没有登录过
if (!sessionStorage['token']) {
    // 保证index.html和login.html一定要在服务器的根路径
    window.location.href = "/login.html"
}
```

### 2.1 导航点击切换页面

因为这里还没学路由(以后vue使用的叫路由), 没办法点击一个按钮 切换 一套div标签, 所以这里采用iframe嵌入另一个完整的html网页

而且点击左侧导航a标签, 点击时, href是跳转的地址, target必须等于iframe的name的值, 点击a就会在iframe里展示a的href指定的网页啦

![image-20201202233140856](images/image-20201202233140856.png)

* 在工程中, 把所有的页面文件夹+html+css+js准备好 (老师直接把iframe发给学生-js都是空的, css和标签现成的)

![image-20201202234317492](images/image-20201202234317492.png)

* 测试点击是否能切换页面

### 2.2 渲染头像

头像分为字母头像和正常的图片头像 - 演示一下(新注册的, 和已有的头像的账号)

介绍标签 - 分为2个

这里先实现字母头像的使用

在api/api.js中, 新增一个网络请求 - 获取个人信息

```js
// 个人信息
const getUInfoAPI = (data, fn) => axios({
    method: "GET",
    data: data,
    url: "/my/userinfo"
}).then(fn);
```

但是发现, 个人信息的多个接口, 都要携带请求头, 以及需要登录的token值

但是登录是在login.html页面的login.js成功获取的, 而现在是要在api.js里使用啊 - 如何跨js文件传值呢? (利用sessionStorage)

login.js -> 登录成功 -> 存储token到浏览器本地sessionStorage对象里

```js
$("#login .layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = {
        username: $("#login input[name=username]").val(),
        password: md5($("#login input[name=password]").val())
    }
    var argStr = objToArg(data);
    loginAPI(argStr, res => {
        // 1. 把token的值保存起来
        sessionStorage['token'] = res.data.token;
        window.location.href = "./index.html";
    });
})
```

api.js -> 获取个人信息 -> 再从浏览器本地sessionStorage取值

```js
const userInfoAPI = (data, fn) => axios({
    method: "GET",
    data: data,
    url: "/my/userinfo",
    // 1. 这次axios(ajax请求), 需要带一个头部的信息一起发给后台 - 后台从这个token字符串提取出你是谁的关键信息, 才知道返回谁的用户信息
    headers: {
        "Authorization": sessionStorage['token']
    }
}).then(fn);
```

在index.html中引入axios.js / api/api.js / index.js - 

在业务的index/index.js - 调用封装的userInfoAPI方法来完成个人信息的获取 - 显示==新==用户字母头像

```js
// 2. 定义方法, 获取用户基本信息
// 把用户的token字符串(包含用户名)(类似于appkey) - 发给后台 (后台得知道你是谁)
// 发送参数: url?后面, body体发, 请求头
window.getInfo = function(){
    getUInfoAPI({}, res => {
        // 3. 根据返回的用户信息, 来做字母头像/真实头像
        let {nickname, user_pic, username} = res.data.data;
        // 欢迎文字: 
        if (nickname == null) {
            nickname = username;
        }
        $(".username").html(nickname);

        // 字母头像 / 真实头像
        if (user_pic == null) { // 要使用字母头像
            // 提取nickname的首字母
            let firstLetter = nickname[0].toUpperCase();
            $(".avatar").html(firstLetter).css("display", "inline-block");
        } else { // 使用真实头像
            $(".avatar").hide();
            $(".layui-nav-img").attr("src", user_pic).show();
        }
    })
}
getInfo();
```

> ## jwt设计

token字符串的作用 - 登录后获取到 - 以后在请求后台(作为一个身份令牌, 让后台知道你是谁的一串字符串)

之前用的token字符串, 全名叫做jwt

jwt (JSON Web Token) - 是`代替密码的一种鉴权的字符串技术 (==服务器只负责颁发jwt字符串, 不负责存储==)

前台提交账号+密码 - 后台到数据库里进行配对 (如果同时都符合证明登录成功)

后台会生成一个jwt字符串

* jwt 头   {shuo: "rsa", zuo: "token"} - 说明信息 (JS对象)

* jwt 体 payload {uid: 用户的id值, 过期时间: 2h, 生成的时间: 2020-09-01 20:33:44} - 用户的信息

* jwt sign 值 - 把前2个base64编码后生成的字符串(为了防止前端篡改) 按照如下这个格式生成sign字符串

  * ```js
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      secret)
    ```

* 后台把上面的3个部分拼接, 形成一串英文: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjYyMCwiaWF0IjoxNjA3MjIwNDg1LCJleHAiOjE2MDcyMjA0ODV9.aYBXvTJLFQ5vs5tBSTmJbz-2x01cY-ZsoVRBogWl_40

账号和密码登录成功后, 后台会返回一个字符串叫jwt, 这个字符串是后台生成的, 里面包含了这个用户的信息(例如id 过期时间等等)

以后请求需要鉴权的api接口, 需要把这个值带给后台, 后台会先判断你是否合法用户, 再决定是否给你服务

而且后台什么都不需要保存 , 也不用在数据库保存 用户的登录状态

![image-20200606161801897](images/image-20200606161801897.png)

### 2.4 安全 - 过期判断

前台判断: 把登录的时间保存在浏览器本地, 再进入index.html页面, 取出来和系统时间对比, 例如超过2小时就判定为过期了, 直接强制跳回到登录页面  (但是前端时间用户可以自己改, 所以不建议使用)

后台配合判断: token里包含了用户登录的时间, 所以我们在index.js页面, 在获取个人 信息的时候, 发送了token给后台, 所以后台会判断, 如果过期了, 返回http状态码为403, 前端只需要等着后段返回的结果判断一下就可以了

* 调试, 在Application/sessionStorage下属里, 修改token的值(不要删除, 删除直接走2.3上一节里的判断了), 在index.html刷新, 观察network/的网络请求, 发现403了

> ## 响应拦截器错误处理

把上面响应拦截器, 放到api.js 最上面, 然后写入代码 判断如果token去后台验证的结果是403回来, 也直接跳回到首页

```js
// 添加响应拦截器
// 思路: login.js的submit调用registerAPI方法 -> 触发axios请求 -> 到后台得到响应数据 -> 回来被响应拦截器拦住判断 -> 再决定要不要执行then -> 执行then里再调用外面的registerAPI传入的函数体执行具体逻辑代码
axios.interceptors.response.use(function (response) { // 当http状态为2开头或者3开头进这里
    // 对响应数据做点什么
    var layer = layui.layer;
    let { message, status } = response.data; // 把后台返回的对象, 解构赋值, message后台返回的提示消息, status后台返回的逻辑状态码(0完全成功(逻辑正确, 注册成功), 1网络请求虽然成功了, 但是逻辑失败了(用户名已占用))
    layer.msg(message); // 逻辑上无论正确还是错误, 都要弹窗
    if (status == 0) { // 逻辑码为0的时候, 执行then里的回调函数
        return response; // 就是把响应的数据传给then的回调函数的形参上
    } else { // 逻辑码为非0, 逻辑错误, 不让then执行了
        return Promise.reject(message); // 必须要return一个Promise的错误到控制台中, 阻止then的回调函数执行
    }
}, function (error) { // 当http状态码为4或5开头, 进这里
    let { response: { data: { message } } } = error;
    layer.msg(message, { // 1.5s自动关闭弹窗
        time: 1500, 
        end: function () { // 弹出层消失以后, 执行这个回调函数执行
            sessionStorage.removeItem("token"); // 因为过期了, 要把本地的token移出掉
            window.parent.location.href = "/login.html" // window.parent拿到了父网页的窗口对象 (window是如果在userInfo是子网页的对象)
            // .代表当前文件所在文件夹
            // ..代表上一级文件夹
            // /代表当前网页在浏览器url的根地址(浏览器运行后的地址来看) - vscode会把当前工程目录看成根路径
        }
    });
    // 对响应错误做点什么
    return Promise.reject(error);
});
```

* 而且我们也可以在响应拦截器里, 统一封装弹窗
* 而且如果逻辑错了, 不能让axios的then函数执行, 所以在请求拦截器里, return Promise.reject() 可以防止then函数的执行

### 2.5 安全 - 用户主动退出

因为后台不保存用户的状态, 只检验用户的token, 所以只要前端删除了本地的token, 

那么前端就无法进入index.html页面了(因为index.js第一行有判断呀, 如果localStorage里没有token就进不去了)

在index.js下面继续编写代码:

```js
// 2. 退出
let layer = layui.layer;
$("#logout").on("click", () => {
    // 提示框
    layer.confirm("确定退出?", {icon:3, title: "提示"}, () => {
        // 确定就执行这里
        // 清除本地的token - 跳转页面
        localStorage.removeItem("token");
        window.location.href = "/login.html";
    });
})
```

## 3. home页面

标签和样式和JS 都已经在预习资料iframe文件夹里了

嵌入在index管理页面 - 第一个子页面home.html页面

这里使用之前学过的echarts.js插件 编写的首页页面 - (暂无接口/数据是固定的)

以后工作时候 - 即使有数据 - 也是把数据部分换成ajax请求 - js都是一样的(这里我们不讲解echarts因为你们以前有经验了) - 这里重点讲的是新东西, 所以首页直接粘贴js即可(有兴趣同学可以课后自己实现一遍echarts.js的图表)

## 4. userInfo页面

修改用户个人的基本信息

==这个页面时一个form标签-表单== 一切都围绕着这个表单来操作

流程(思路): 进入网页 - 进行网络请求(axios/api.js封装接口) -> userInfo.js调用拿到此用户默认信息 -> 铺设到表单上

### 4.0 默认值

刚进入userInfo.html页面的时候, 给表单里赋予这个用户现有的默认值

```js
// 1. 获取用户信息
userInfoAPI({}, res => {
    let {username, email, nickname} = res.data.data;
    $("input[name=username]").val(username);
    $("input[name=nickname]").val(nickname);
    $("input[name=email]").val(email);
})
```

### 4.1 验证输入框

```js
var form = layui.form;

form.verify({ // 指定规则名和对应的验证规则
    nickn: [ // 昵称
        /^[\u4E00-\u9FA5]+$/,
        '昵称只能是中文'
    ],
})
```

### 4.2 提交修改信息

思路: 把前端表单里的值 - 收集起来 - 提交给后台接口即可 (回显提示信息)

看接口文档发现, 需要传给后台如下参数:

* id
* nickname
* email

后2个表单的值, 已经有了, 但是id在哪里呢?  发现form里有个隐藏的表单, name就是 参数 名叫id, 就是它了

> ### 隐藏表单域

我们无需显示给用户让用户输入, 

但是提交的时候, 还想要这个值, 所以我们可以在js代码里把值赋予进去, 然后等提交时候, 收集一下即可了

```html
 <!-- 为了保存它的id, 这叫隐藏域, 方便修改时, 获取id的值 -->
<input type="hidden" name="id" value="">
```

> ### 收集表单值

jQ给我们提供了一个 serialize()方法, 可以收集form里所有name属性的值和value属性的值形成参数名=表单域值&参数名=表单域值的字符串

```js
var data = $(".layui-form").serialize();
```

在userInfo.js 把收集到的表单字符串 发给后台即可

```js
// 2. 提交修改
$(".layui-form").on("submit", ev => {
    ev.preventDefault();
    var data = $(".layui-form").serialize();
    upUserInfoAPI(data);
})
```

### 4.3 重置按钮

在获取个人信息的函数里, 直接用外层函数上的变量, 在点击重置按钮, 重新给可修改的标签重新赋值即可

```js
// 3. 重置按钮
// 把上面用户的信息, 重新铺设一遍
$(".my-reset").on("click", (ev) => {
    ev.preventDefault();
    $("input[name=nickname]").val(nickname);
    $("input[name=email]").val(email);
})
```

## 5. repwd页面

重置密码页面的功能编写repwd.html 和 repwd.js的编写

### 5.0  修改密码 - 表单验证==common/verify.js==

和注册页面和登录页面一样, 都需要pwd验证名字, 在login.js中

* 要么复制过来 (但是太low了.. 如果以后还有 再复制??)
* 所以最好封装起来 (放到一个工具里) - 不要散落在各个逻辑的js文件中

在common公共的文件夹里, 新增verify.js文件 - 里面只编写表单验证相关的代码如下

修改login.js里的 和 userInfo.js里的, 都使用这个公共的验证规则文件

```js
// 修改密码验证 - 刚加的验证
var form = layui.form;

form.verify({
    usern: [ // 用户名
        /^[a-z0-9]{6,10}$/,
        '账号名是6到10位由数字, 小写字母组成'
    ],
    pwd: [ // 密码
        /^[\S]{6,10}$/,
        '密码是6到10位, 不能有空格'
    ],
    // 注册页-确认密码
    repwd: function (value) {
        return ($(".pwd").val() !== value) && '两次密码不相同'
    },
    nickn: [ // 昵称
        /^[\u4E00-\u9FA5]+$/,
        '昵称只能是中文'
    ],

    // 修改密码页面使用 - 新旧密码不能一样
    diff: function(value){
        return ($(".oldPwd").val() == value) && "新密码和旧密码不能一样"
    },
    // 修改密码页 - 使用
    same: function(value) {
        return ($(".newPwd").val() !== value) && '两次密码不相同'
    }
})
```

### 5.1 密码修改 - 自动退出 - 重新登录

api/api.js - 新增 接口方法

```js
// 重置密码
const rePassAPI = (data, fn) => axios({
    method: "POST",
    data: data,
    url: "/my/updatepwd"
}).then(fn);
```

repwd.js 实现逻辑

点击后把旧密码和新密码传给后台, 以及携带token(让后台知道你是谁, 改谁的密码)  

修改成功后, 清除本地sessionStorage里的token, 然后跳转回登录页面

```js
// 1. 重置密码 - 表单提交
$(".layui-form").on("submit", ev => {
  ev.preventDefault();

  let data = {
    oldPwd: md5($("input[name=oldPwd]").val()),
    newPwd: md5($("input[name=newPwd]").val())
  }
  // 后台不支持json, 所以必须用objToArg方法转成key=value
  rePassAPI(data, () => {
    // 重置成功
    let s = setTimeout(() => {
      sessionStorage.removeItem("token");
      // 这里要格外注意, window指的是iframe内嵌的网页repwd页面, 而我们想让index.html整个网页跳转到登录页面, 所以window.parent - 返回当前窗口的父窗口对象
      window.parent.location.href = "/login.html";
      clearTimeout(s)
    }, 2000);
  })
})
```

## 6. avatar页面

修改用户的头像 - 

这里我们想要使用插件图片的插件

### 6.0 导入裁剪插件使用

找插件 - 下插件 - 引插件 - 用插件 - 改配置

* 引入cropper.css
* 引入jQuery.js  (因为这个cropper插件里面代码都用jQuery.js写的)
* 引入 cropper.js
* 引入jquery-cropper.js

```js
// 1. 初始化裁剪插件
let cropper = new Cropper($("#image")[0], {
    aspectRatio: 1, // 裁剪图层的横纵比例
    preview: $(".img-preview") // 多看文档里每个属性的意思, 一般都会有, 实在没用自己写/换个插件
});
```

### 6.1 从电脑选择文件

```js
<!-- 隐藏文件选择框, 太丑了, 我们JS监测用户点击选择图片按钮后, 在JS触发file文件选择标签一样能弹出选择文件的窗口 -->
<!-- accept - 控制弹出窗口显示的文件类型 -->
<input type="file" id="file" style="display: none;" accept="image/png, image/jpeg, image/gif">

// 2. 偷天换日 - 点击按钮 -偷摸让别的按钮触发了点击事件
$(".select").on("click", e => { // // input[type=file]标签的样式改不动, 所以我们用button[class=select]按钮来让用户点击
    $("#file").click();  // JS代码来主动触发input[type=file]的点击事件 - 选择文件的窗口就出来
})

// 3. 选择文件窗口出现 - 选中文件点击打开, 会触发change事件
$("#file").on("change", function(e){
    var url = URL.createObjectURL(this.files[0]); // URL是window内置的对象, createObjectURL就是把blob对象(File的父类)转成url地址(浏览器本地的-跟后台无关)
    cropper.replace(url); // 让cropper重新设置图片url地址以及重新构建cropper
})

```

补充知识点: 浏览器本地操作图片文件对象

File - 是什么

Blob - 是什么

URL内置对象 - createObjectURL的方法作用: 传入Blob类型, 可以得到一个url地址(浏览器本地生成的url地址)

### 6.2  上传头像

```js
// 4. 确定按钮 - 点击事件
$(".sure").on("click", ev => {
    var canvas = cropper.getCroppedCanvas({ // 利用cropper的方法, 把裁剪区域输出到一个canvas标签上 // width和height是canvas标签的大小
        width: 100,
        height: 100
    });
    var base64Str = canvas.toDataURL("image/jpeg"); // canvas图像 -> base64字符串
    // image/jpeg 是对标签输出的base64字符串做出一个类型的标记
    // 等一会儿把头像base64字符串, 放到img标签的src上, img标签根据类型就知道如何解析这串base64字符串

    // 因为base64Str有一些特殊的符号, 前端要进行URL编码, 再传给后台(node+express)会进行URL解码
    base64Str = encodeURIComponent(base64Str);
    var argStr = "avatar=" + base64Str;
    upHeadImgAPI(argStr, res => {
        // 让父窗口的getInfo方法执行, 请求最新的头像更新父页面
        window.parent.getInfo();
    })
})
// 图片: 本质上0和1的数字. 把0和1转成字符串表示 - (把图片的0和1数据, 按照加密方式, 转成base64字符串) base64的原理
// canvas: 是html5新出的标签, 可以在它的身上任意的绘制任意的内容(包含图片)
```

> ### 新的知识点

* canvas标签 - 是HTML5新出的一个标签,  它是一个画布(里面是图片)
* base64 字符串 - canvas标签自带方法, 可以把canvas里的信息, 输出成base64字符串

前端 -- JS代码 --获取/设置 图片: 

从input[type=file]中 - 获取时是File类型(特殊的Blob)的文件 / 图片通过canvas->转成base64字符串

设置给img标签的src属性 可以是URL地址 / base64字符串

### 6.3 设置默认头像

如果用户已经上传过头像了, 想要换一张, 默认应该显示上一次传的头像图片

在avatar.js 最外层套起来

```js
userInfoAPI({}, res => {
    var { user_pic } = res.data.data;
    // 如果有头像, 就设置到头像img标签上
        if (user_pic) $("#image").attr("src", user_pic);
 	// 然后再初始化 Cropper插件
});
// 调用这个api/api.js里网络请求的方法, 获取用户现在的信息, 包含用户头像base64字符串
```

### 6.4 axios请求拦截器

有很多接口都需要携带请求头, 所以可以统一封装到请求拦截器里, 任何ajax请求都被这里先处理一下再发送请求

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    if (!config.url.startsWith("/api")) { // 不是/api开头的字符串, 都要携带Authorizetion
        // 千万注意, 是往headers身上添加key  (千万别写成config.headers = 这种)
        config.headers['Authorization'] = sessionStorage['token'];
    }
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});
```

## 7. category页面

文章管理 - 类别管理页面

### 7.0 添加类别

右上角按钮  - 绑定点击事件 - 出现弹出层(是一个form标签表单)

* 这里还有几个新的lay-verify的值, 用户规定类别名称和别名
* 规则名字 common/verify.js中 新增2个规则名字 - 用到下面标签字符串的规则中

```js
// category - 新增分类 - 表单规则 (但是这是前段验证, 如果直接调用接口传英文, 咱们限制不住, 所以后端也得有验证规则-double保险)
    ctname: [
        /^[\u4E00-\u9FA5]+$/,
        "分类名只能是中文"
    ],
    aliname: [
        /^[a-z0-9]+$/,
        "小写英文和数字组成"
    ],
```

* 添加类别 弹出层的 事件 和 form标签

```js
var layer = layui.layer;
// 1. 添加类别 - 
// 添加弹窗 - 要用在弹窗中的字符串, 所以没写在标签里
var add_str = `
<form class="layui-form add-form" action="" style="margin: 30px; margin-left: 0px;" id="add_form">
<div class="layui-form-item">
  <label class="layui-form-label">类别名称</label>
  <div class="layui-input-block">
    <input type="text" name="name" required lay-verify="required|ctname" placeholder="请输入标题" autocomplete="off" class="layui-input">
  </div>
</div>
<div class="layui-form-item">
  <label class="layui-form-label">类别别名</label>
  <div class="layui-input-block">
    <input type="text" name="alias" required lay-verify="required|aliname" placeholder="请输入标题" autocomplete="off" class="layui-input">
  </div>
</div>
<div class="layui-form-item">
  <div class="layui-input-block">
    <button class="layui-btn" lay-submit lay-filter="formDemo">确认添加</button>
    <button type="reset" class="layui-btn layui-btn-primary">重置</button>
  </div>
</div>
</form>`;

// 1. 添加类别按钮 - 点击事件
$(".add").on("click", e => {
    let index = layer.open({
        type: 1,
        content: add_str,
        title: "新增分类",
        area: ['500px', '300px'],
        // 2. 因为add-form是在弹出层上
        success() { // 所以必须等弹出层出现以后, 才能 绑定submit事件
            $(".add-form").on("submit", e => {
                e.preventDefault();
                // 3. JQ的serialize方法: 返回的是key=value&key=value的字符串
                // form.val()返回的是对象
                let argStr = $(".add-form").serialize();
                // 4. 调用接口, 把分类发给后台
                addCateAPI(argStr, res => {
                    layer.close(index);
                    load();
                })
            })
        }
    });
})
```

### 7.1 获取类别 - 铺设页面

在api/api.js中, 新增网络请求方法 - 里面是axios请求(以及请求的接口url地址)

getCategoryAPI 方法

```js
// 5. 获取现有的分类 - 铺设页面
function load() {
    cateListAPI({}, res => {
        // 6. 提取数据
        let arr = res.data.data;
        $(".layui-table tbody").empty();
        arr.forEach(obj => {
            let theTr = `<tr>
            <td>${obj.name}</td>
            <td>${obj.alias}</td>
            <td>
              <button myid="${obj.Id}" data-name="${obj.name}" data-alias="${obj.alias}" type="button" class="layui-btn layui-btn-xs edit">编辑</button>
    
              <button myid="${obj.Id}" type="button" class="layui-btn layui-btn-xs layui-btn-danger delete">删除</button>
            </td>
          </tr>`;
            $(".layui-table tbody").append(theTr);
        })
    })
}
load();
```

### 7.2 编辑类别

点击后 还是用模态框来显示表单 - 然后把点击的那个标签绑定的数据默认先显示, 点击提交, 收集模态框里的表单数据 传给 后台的 修改分类名字的接口

* 类别的输入框上还有正则的限制, 所以直接调用common/verify.js中的那2个规则还能继续使用

```js
// 3. 编辑分类
// 也要用在弹窗上面
var edit_str = `
  <form class="layui-form add-form" action="" style="margin: 30px; margin-left: 0px;" id="edit_form" lay-filter="edit">
    <div class="layui-form-item">
      <label class="layui-form-label">类别名称</label>
      <div class="layui-input-block">
        <input type="text" name="name" required lay-verify="required|ctname" placeholder="请输入标题" autocomplete="off" class="layui-input">
      </div>
    </div>
    <div class="layui-form-item">
      <label class="layui-form-label">类别别名</label>
      <div class="layui-input-block">
        <input type="text" name="alias" required lay-verify="required|aliname" placeholder="请输入标题" autocomplete="off" class="layui-input">
      </div>
    </div>
    <input type="hidden" name="Id">
    <div class="layui-form-item">
      <div class="layui-input-block">
        <button class="layui-btn" lay-submit >确认修改</button>
      </div>
    </div>
  </form>`;

// 事件委托 - 编辑按钮 - 点击事件
$(".layui-table tbody").on("click", ".edit", function () { // this: 编辑按钮
    // 10. 编辑按钮 - 出现弹出层 - 弹出层的form标签里, 要出现默认值
    // 编辑按钮身上 - 绑定的自定义属性的值(Id, name, alias, 分类名字和别名)
    var Id = $(this).attr("myid");
    var name = $(this).attr("data-name");
    var alias = $(this).attr("data-alias");

    let index = layer.open({
        type: 1,
        content: edit_str,
        title: "编辑分类",
        area: ['500px', '300px'],
        success() {
            // 11. 只要弹出层出现了(form表单出现), 编辑按钮对应的10步数据, 默认显示在输入框里
            // (1): layui.form管理整个项目所有的form标签, 所以要用lay-filter的值来区分
            let form = layui.form;
            form.val("edit", { // 传入一个对象, key和上面的变量名重名了
                Id: Id,
                name,
                alias
            })
            // 12. 用户改完后 - 点击提交按钮
            $(".add-form").on("submit", e => {
                e.preventDefault();
                // 自己来收集数据, 发给后台
                let argStr = $(".add-form").serialize();
                updateCateAPI(argStr, res => {
                    layer.close(index)
                    load();
                })
            })
        }
    });
})
```

### 7.3 删除类别

这里新学知识点, url路径也可以传参 - 但是需要后台提前支持

```js
// 7. 事件委托 - 删除按钮 - 点击事件
$(".layui-table tbody").on("click", ".delete", function () {
    // this指向的是: 调用者(删除的button按钮)
    // 拿到要删除的这条数据绑定的Id值 $(this).attr("myid")
    // 8. 调用接口 - 让后台把id对应的数据再后台抹掉, 前台同步
    delCateAPI($(this).attr("myid"), res => {
        // 当前的删除的按钮对应的tr一行标签自爆
        $(this).parents("tr").remove();
    })
});
```

`注意` DOM操作频繁会降低网站性能=>简化DOM操作



## 8. publisher页面

发布文章页面

### 8.0 文章发布 - 表单验证

* 先自定义表单验证器 在common/verify.js中新增2对key:value, 增加字段验证规则

```js
// publisher页面 - 文章标题
articleTitle: [
    /^[\u4E00-\u9FA5a-zA-Z0-9_-]+$/,
    "标题只能是中英文, 数字下划线中划线组成"
],
// 分类判断
cate: function(){
	return $("select[name=cate_id]").val().length == 0 && "请选择分类"
}
```

publisher.html里的form标签里的值 - 需要lay-verify设置表单验证的规则名字

### 8.1 分类列表 - 初始化

```js
// 1. 获取所有的分类 - 铺设到下拉菜单中
cateListAPI({}, res => {
    let arr = res.data.data;
    arr.forEach(obj => {
        var theOption = `<option value="${obj.Id}" lay-verify="cate">${obj.name}</option>`;
        $("select[name=cate_id]").append(theOption);
        // 让layui刷新一下form表单
        layui.form.render('select', 'edit');
    })
})
```

### 8.2 初始化富文本插件

富文本编辑器 - 可以插入不止字符串的而且带格式/内嵌图片的大段文本内容 (正常新闻页面, 后台保存的都是富文本)

直接引入我们的tinymce_setup.js文件, 已经封装好了, 可以跳转进去看看

具体详细配置项 可以看文档 即可

![image-20201204210705527](images/image-20201204210705527.png)

```js
// 2. 集成富文本编辑器
function initTinyMce() {
    tinymce.init({
        selector: 'textarea[name=content]', //容器，可使用css选择器
        language: 'zh_CN', //调用放在langs文件夹内的语言包
        plugins: ['link', 'table', 'image'], //选择需加载的插件
        // //选中时出现的快捷工具，与插件有依赖关系
        // quickbars_selection_toolbar: 'bold italic forecolor | link blockquote quickimage',
    });
}
initTinyMce();
```

### 8.3 初始化封面插件

```js
// 3. 集成图片裁剪的插件
let cropper;
function initCropper() {
    // 1. 集成裁剪插件
    const image = document.getElementById('image'); // 获取到要被添加裁剪插件的图片
    cropper = new Cropper(image, {
        aspectRatio: 1, // 横纵比例
        preview: $(".img-preview")
    });
}
initCropper();
```

### 8.4 发布文章

把页面的数据 - 收集起来 - 发给后台接口

注意: 接口说了, 必须是FormData格式

```js
// 5. 发布文章 - 表单 - 提交事件
$(".layui-form").on("submit", e => {
    e.preventDefault();
    // 富文本里的东西取出(唯一的用activeEditor)
    var htmlStr = tinyMCE.activeEditor.getContent();
    // 把封面图片的裁剪区域提取出来
    var canvas = cropper.getCroppedCanvas({
        width: 100,
        height: 100
    });

    // 后台要的是FormData数据类型(内容载体)
    let fd = new FormData($(".layui-form")[0]);
    fd.set("content", htmlStr); // set(设置值), append(新增)

    // 把canvas -> File(Blob)文件对象 (异步任务)
    canvas.toBlob(function (blobObj) {
        fd.append("cover_img", blobObj);

        // fd.forEach((value, key) => {
        //     console.log(value, key);
        // })

        if (id) { // 本次是想编辑更新
            fd.append("Id", id);
            updateArtAPI(fd, res => {
                console.log(res);
                setTimeout(() => {
                    window.location.href = "../list/list.html";
                }, 1500);
            })
        } else { // 发布新文章
            // 6. 调用后台 - 发布文章的接口
            addArtAPI(fd, res => {
                // / 在浏览器运行的地址栏上的"根路径"
                // . 当前文件夹
                // .. 上一级文件夹  (../..)上一级的上一级文件夹
                // ./当前文件夹下的什么什么
                // ../上一级文件夹下的什么什么
                setTimeout(() => {
                    window.location.href = "../list/list.html";
                }, 1500);
            })
        }
    })
})
```

## 9. list页面

查看文章 - 文章列表

### 9.0 文章列表 -  铺设

```js
var allCount = 0; // 保存的是后台现有的文章总数
let q = {
    pagenum: 1, // 页数(你要第几页的数据)
    pagesize: 2, // 每页"要"多少条数据
    cate_id: "", // 分类ID (可选, 可以给值也可以不给值)
    state: "已发布", // (已发布, 草稿) 只能是这2个值
}

// 1. 获取文章数据列表
function load(){
    artListAPI(q, res => {
        // 2. 把数据铺设到页面上
        let arr = res.data.data;
        // (重要不好理解): 当前页码对应的数据没有了, 虽然分页器能自动跳转到上一页页码, 但是q对象的pagenum还是当前这页, 所以我们需要自己来写js判断,(判断条件就是看当前这页是否还有数据)
        if (arr.length === 0) { // 证明当前这页没有数据了
            q.pagenum--;
            load(); // 再用上一页的页码, 重新请求上一页的数据
            return;
        }
        allCount = res.data.total; // 后台返回的数据总数, 放到了全局变量上
        $(".layui-table tbody").empty();
        arr.forEach(obj => {
            var theTr = `<tr>
                            <td>${obj.title}</td>
                            <td>${obj.cate_name}</td>
                            <td>${obj.pub_date}</td>
                            <td>${obj.state}</td>
                            <th>
                            <a href="/iframe/article/publisher/publisher.html?id=${obj.Id}" class="layui-btn layui-btn-xs">编辑</a>
                            <button myid="${obj.Id}" type="button" class="layui-btn layui-btn-xs layui-btn-danger del">删除</button>
                                </th>
                        </tr>`;
            $(".layui-table tbody").append(theTr);
        })
            setPage(); // 生成分页器
    })
}
load();
```

补充: 在common/utils.js 中, 添加工具方法 formatData, 来美化时间

```js
// 美化日期的方法
function formatDate(dateStr) { // data数据, date时间
    var theDate = new Date(dateStr);
    // 按照我们想要的格式, 年-月-日 时:分:秒
    var year = theDate.getFullYear();
    var month = theDate.getMonth() + 1;
    var day = theDate.getDate();
    var hours = theDate.getHours();
    var minutes = theDate.getMinutes();
    var seconds = theDate.getSeconds();

    var fn = val => val < 10 ? '0' + val : val;
    return [year, month, day].map(fn).join("-") + " " + [hours, minutes, seconds].map(fn).join(":");
}
```

### 9.1 文章列表 - 筛选表单

请求分类数据铺设后, 再绑定筛选表单提交的事件

```js
// 4. 类别数据获取和铺设
cateListAPI({}, res => {
    let arr = res.data.data;
    $("select[name=category]").append(`<option value="" lay-verify="cate">所有分类</option>`); // 默认选项- 默认获取所有分类
    arr.forEach(obj => {
        var theOption = `<option value="${obj.Id}" lay-verify="cate">${obj.name}</option>`;
        $("select[name=category]").append(theOption);
    })
    
    // 让layui刷新一下form表单
    layui.form.render('select', 'category');

    // 5. 分类数据回来了, 再绑定筛选表单的submit事件
    $(".search").on("submit", e => {
        e.preventDefault();
        // 把下拉菜单的值, 放到参数q对象里, 再让load执行一次, 把参数对象q发给后台, 获取新的数据, load铺设页面
        q.cate_id = $("select[name=category]").val();
        q.state = $("select[name=state]").val();
        load();
    })
})
```

### 9.2 文章列表 - 分页生成和使用

```js
// 2. 分页器 - 初始化
function setPage(){
    var laypage = layui.laypage;
    //执行一个laypage实例
    laypage.render({
        elem: 'page', // 分页所在的容器标签的ID, 不需要#
        count: allCount, // 数据总数，从服务端得到
        limit: q.pagesize, // 每页显示的条数
        limits: [2, 5, 10, 20], // 下拉组件每个条数
        layout: ['count', 'prev', 'page', 'next', "limit", "skip"],
        curr: q.pagenum, // setPage只要调用, 分页器就会重新生成, 所以要设置起始页
        jump: function(obj, first){ // 3. 分页改变时, 回调这个函数执行
            // obj包含了当前分页的所有参数，比如：
            console.log(obj.curr); // 得到当前页，以便向服务端请求对应页的数据。
            console.log(obj.limit); // 得到每页显示的条数
            // laypage.render每次调用初始化分页器, 会让jump马上触发, 调用load后, setPage又调用. laypage.render有执行, jump又调用, load --- 循环卡死. 
            // 首次不执行 -第一次渲染这个分页器的时候first是true, 其他时候是undefined
            if(!first){
                q.pagenum = obj.curr; // 把页面同步到参数q对象身上
                q.pagesize = obj.limit; // 同步选中当前页有多少条数据到q对象身上
                load();
            }
        }
    });
}
```

### 9.3 修改文章

使用发布文章的publisher页面, 在list页面点击编辑按钮的时候, 把文章的id值, 传递到list.html页面 (这是跨页面传参) - 跳转页面是通过url链接, 所以可以在url后面?拼接id的值 - 把文章id传入到publisher页面

1. 在publisher.html页面, 第一行判断url上有没有形参, 如果有就证明是从编辑页面过来的
2. 从url上, 获取id的值, 然后请求这个id的值对应的文章信息, 默认先显示到publisher.html这个页面的表单里

注意是先设置 图片和富文本的内容.  

然后再初始化 富文本插件, 再初始化拆减图片的插件哦

收集文章输入框表单的值 - 送到更新文章的接口 - 让后台更新文章数据 - 前端返回到list.html页面即可

```js

// 0. 因为这个 页面可能是点击发布过来的 / 点击编辑按钮 过来的
// 如果是点击编辑按钮, url上?后面会有id的参数
let argStr = location.search;
let id = argStr.substr(4); // ?id=xxx 我们要后面的id值, 前面?id= 正好4位略过, 从4开始截取后面的id
if (id) { // 获取文章的详情
    detailArtAPI(id, res => {
        // 铺设到页面上
        layui.form.val("edit", res.data.data);
        // (1): 下拉菜单的选择问题
        layui.form.render('select', 'edit');
        // (2): 让裁剪插件也替换一下
        cropper.replace(res.data.data.cover_img);
    })
}
```

### 9.4 删除文章

```js
// 6. 删除按钮 - 事件委托 - 点击事件
$(".layui-table tbody").on("click", ".del", function(){ // this: 事件源删除按钮
    // id拔下来  $(this).attr("myid");
    // 调用删除接口通知后台把这条数据删除
    delArtAPI($(this).attr("myid"), res => { // 这个回调函数能进来证明完全成功(响应拦截器里有判断)
        load();
    })
})
```

